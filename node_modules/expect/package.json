{
  "_args": [
    [
      {
        "raw": "expect@1.19.0",
        "scope": null,
        "escapedName": "expect",
        "name": "expect",
        "rawSpec": "1.19.0",
        "spec": "1.19.0",
        "type": "version"
      },
      "/Users/omkar/workspace/EducationOne"
    ]
  ],
  "_from": "expect@1.19.0",
  "_id": "expect@1.19.0",
  "_inCache": true,
  "_location": "/expect",
  "_nodeVersion": "5.9.1",
  "_npmOperationalInternal": {
    "host": "packages-16-east.internal.npmjs.com",
    "tmp": "tmp/expect-1.19.0.tgz_1462228635926_0.07432770426385105"
  },
  "_npmUser": {
    "name": "mjackson",
    "email": "mjijackson@gmail.com"
  },
  "_npmVersion": "3.7.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "expect@1.19.0",
    "scope": null,
    "escapedName": "expect",
    "name": "expect",
    "rawSpec": "1.19.0",
    "spec": "1.19.0",
    "type": "version"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/expect/-/expect-1.19.0.tgz",
  "_shasum": "14139fd4a933cdcad51775e4c51423b27b68b5cf",
  "_shrinkwrap": null,
  "_spec": "expect@1.19.0",
  "_where": "/Users/omkar/workspace/EducationOne",
  "author": {
    "name": "Michael Jackson"
  },
  "babel": {
    "presets": [
      "es2015"
    ]
  },
  "bugs": {
    "url": "https://github.com/mjackson/expect/issues"
  },
  "dependencies": {
    "define-properties": "~1.1.2",
    "has": "^1.0.1",
    "is-equal": "^1.5.1",
    "is-regex": "^1.0.3",
    "object-inspect": "^1.1.0",
    "object-keys": "^1.0.9",
    "tmatch": "^2.0.1"
  },
  "description": "Write better assertions",
  "devDependencies": {
    "babel-cli": "^6.6.5",
    "babel-eslint": "^6.0.0",
    "babel-loader": "^6.2.4",
    "babel-preset-es2015": "^6.6.0",
    "eslint": "^2.5.1",
    "eslint-config-airbnb": "^6.2.0",
    "eslint-plugin-react": "^4.2.3",
    "gzip-size": "^3.0.0",
    "karma": "^0.13.22",
    "karma-browserstack-launcher": "^0.1.10",
    "karma-chrome-launcher": "^0.2.3",
    "karma-mocha": "^0.2.2",
    "karma-mocha-reporter": "^2.0.0",
    "karma-sourcemap-loader": "^0.3.7",
    "karma-webpack": "^1.7.0",
    "mocha": "^2.4.5",
    "pretty-bytes": "^3.0.1",
    "readline-sync": "^1.4.1",
    "rimraf": "^2.5.2",
    "webpack": "^1.12.14"
  },
  "directories": {},
  "dist": {
    "shasum": "14139fd4a933cdcad51775e4c51423b27b68b5cf",
    "tarball": "https://registry.npmjs.org/expect/-/expect-1.19.0.tgz"
  },
  "files": [
    "lib",
    "umd"
  ],
  "gitHead": "84a9d0007aff0bfcc323444047701133c6ec1747",
  "homepage": "https://github.com/mjackson/expect#readme",
  "keywords": [
    "expect",
    "assert",
    "test",
    "spec"
  ],
  "license": "MIT",
  "main": "lib",
  "maintainers": [
    {
      "name": "ljharb",
      "email": "ljharb@gmail.com"
    },
    {
      "name": "mjackson",
      "email": "mjijackson@gmail.com"
    }
  ],
  "name": "expect",
  "optionalDependencies": {},
  "readme": "# expect [![Travis][build-badge]][build] [![npm package][npm-badge]][npm]\n\n[build-badge]: https://img.shields.io/travis/mjackson/expect/master.svg?style=flat-square\n[build]: https://travis-ci.org/mjackson/expect\n\n[npm-badge]: https://img.shields.io/npm/v/expect.svg?style=flat-square\n[npm]: https://www.npmjs.org/package/expect\n\n[expect](https://github.com/mjackson/expect) lets you write better assertions.\n\nWhen you use `expect`, you write assertions similarly to how you would say them, e.g. \"I expect this value to be equal to 3\" or \"I expect this array to contain 3\". When you write assertions in this way, you don't need to remember the order of actual and expected arguments to functions like `assert.equal`, which helps you write better tests.\n\nYou can think of `expect` as a more compact alternative to [Chai](http://chaijs.com/) or [Sinon.JS](http://sinonjs.org/), just without the pretty website. ;)\n\n## Installation\n\nUsing [npm](https://www.npmjs.org/):\n\n    $ npm install --save expect\n\nThen, use as you would anything else:\n\n```js\n// using ES6 modules\nimport expect, { createSpy, spyOn, isSpy } from 'expect'\n\n// using CommonJS modules\nvar expect = require('expect')\nvar createSpy = expect.createSpy\nvar spyOn = expect.spyOn\nvar isSpy = expect.isSpy\n```\n\nThe UMD build is also available on [npmcdn](https://npmcdn.com):\n\n```html\n<script src=\"https://npmcdn.com/expect/umd/expect.min.js\"></script>\n```\n\nYou can find the library on `window.expect`.\n\n## Assertions\n\n### toExist\n\n> `expect(object).toExist([message])`\n\nAsserts the given `object` is truthy.\n\n```js\nexpect('something truthy').toExist()\n```\n\nAliases:\n  - `toBeTruthy`\n\n### toNotExist\n\n> `expect(object).toNotExist([message])`\n\nAsserts the given `object` is falsy.\n\n```js\nexpect(null).toNotExist()\n```\n\nAliases:\n  - `toBeFalsy`\n\n### toBe\n\n> `expect(object).toBe(value, [message])`\n\nAsserts that `object` is strictly equal to `value` using `===`.\n\n### toNotBe\n\n> `expect(object).toNotBe(value, [message])`\n\nAsserts that `object` is not strictly equal to `value` using `===`.\n\n### toEqual\n\n> `expect(object).toEqual(value, [message])`\n\nAsserts that the given `object` equals `value` using [is-equal](https://www.npmjs.com/package/is-equal).\n\n### toNotEqual\n\n> `expect(object).toNotEqual(value, [message])`\n\nAsserts that the given `object` is not equal to `value` using [is-equal](https://www.npmjs.com/package/is-equal).\n\n### toThrow\n\n> `expect(block).toThrow([error], [message])`\n\nAsserts that the given `block` `throw`s an error. The `error` argument may be a constructor (to test using `instanceof`), or a string/`RegExp` to test against `error.message`.\n\n```js\nexpect(function () {\n  throw new Error('boom!')\n}).toThrow(/boom/)\n```\n\n### toNotThrow\n\n> `expect(block).toNotThrow([message])`\n\nAsserts that the given `block` does not `throw`.\n\n### toBeA(constructor)\n\n> `expect(object).toBeA(constructor, [message])`<br>\n> `expect(object).toBeAn(constructor, [message])`\n\nAsserts the given `object` is an `instanceof constructor`.\n\n```js\nexpect(new User).toBeA(User)\nexpect(new Asset).toBeAn(Asset)\n```\n\nAliases:\n  - `toBeAn`\n\n### toBeA(string)\n\n> `expect(object).toBeA(string, [message])`<br>\n> `expect(object).toBeAn(string, [message])`\n\nAsserts the `typeof` the given `object` is `string`.\n\n```js\nexpect(2).toBeA('number')\n```\n\nAliases:\n  - `toBeAn`\n\n### toNotBeA(constructor)\n\n> `expect(object).toNotBeA(constructor, [message])`<br>\n> `expect(object).toNotBeAn(constructor, [message])`\n\nAsserts the given `object` is *not* an `instanceof constructor`.\n\n```js\nexpect(new Asset).toNotBeA(User)\nexpect(new User).toNotBeAn(Asset)\n```\n\nAliases:\n  - `toNotBeAn`\n\n### toNotBeA(string)\n\n> `expect(object).toNotBeA(string, [message])`<br>\n> `expect(object).toNotBeAn(string, [message])`\n\nAsserts the `typeof` the given `object` is *not* `string`.\n\n```js\nexpect('a string').toNotBeA('number')\nexpect(2).toNotBeAn('object')\n```\n\nAliases:\n  - `toNotBeAn`\n\n### toMatch\n\n> `expect(string).toMatch(pattern, [message])`<br>\n> `expect(object).toMatch(pattern, [message])`\n\nAsserts the given `string` or `object` matches a `pattern`. When using a string, `pattern` must be a `RegExp`. When using an object, `pattern` may be anything acceptable to [`tmatch`](https://github.com/tapjs/tmatch).\n\n```js\nexpect('a string').toMatch(/string/)\nexpect({\n  statusCode: 200,\n  headers: {\n    server: 'nginx/1.6.5'\n  }\n}).toMatch({\n  headers: {\n    server: /nginx/\n  }\n})\n```\n\n### toNotMatch\n\n> `expect(string).toMatch(pattern, [message])`<br>\n> `expect(object).toMatch(pattern, [message])`\n\nAsserts the given `string` or `object` does not match a `pattern`. When using a string, `pattern` must be a `RegExp`. When using an object, `pattern` may be anything acceptable to [`tmatch`](https://github.com/tapjs/tmatch).\n\n```js\nexpect('a string').toMatch(/string/)\nexpect({\n  statusCode: 200,\n  headers: {\n    server: 'nginx/1.6.5'\n  }\n}).toNotMatch({\n  headers: {\n    server: /apache/\n  }\n})\n```\n\n### toBeLessThan\n\n> `expect(number).toBeLessThan(value, [message])`<br>\n> `expect(number).toBeFewerThan(value, [message])`\n\nAsserts the given `number` is less than `value`.\n\n```js\nexpect(2).toBeLessThan(3)\n```\n\nAliases:\n  - `toBeFewerThan`\n\n### toBeLessThanOrEqualTo\n\n> `expect(number).toBeLessThanOrEqualTo(value, [message])`<br>\n\nAsserts the given `number` is less than or equal to `value`.\n\n```js\nexpect(2).toBeLessThanOrEqualTo(3)\n```\n\n### toBeGreaterThan\n\n> `expect(number).toBeGreaterThan(value, [message])`<br>\n> `expect(number).toBeMoreThan(value, [message])`\n\nAsserts the given `number` is greater than `value`.\n\n```js\nexpect(3).toBeGreaterThan(2)\n```\n\nAliases:\n  - `toBeMoreThan`\n\n### toBeGreaterThanOrEqualTo\n\n> `expect(number).toBeGreaterThanOrEqualTo(value, [message])`<br>\n\nAsserts the given `number` is greater than or equal to `value`.\n\n```js\nexpect(3).toBeGreaterThanOrEqualTo(2)\n```\n\n### toInclude\n\n> `expect(array).toInclude(value, [comparator], [message])`<br>\n> `expect(object).toInclude(value, [comparator], [message])`<br>\n> `expect(string).toInclude(value, [message])`\n\nAsserts that a given `value` is included (or \"contained\") within another. The `actual` value may be an array, object, or a string. The `comparator` function, if given, should compare two objects and `return false` if they are not equal. The default is to use [`isEqual`](https://github.com/ljharb/is-equal).\n\n```js\nexpect([ 1, 2, 3 ]).toInclude(3)\nexpect({ a: 1, b: 2 }).toInclude({ b: 2 })\nexpect({ a: 1, b: 2, c: { d: 3 } }).toInclude({ b: 2, c: { d: 3 } })\nexpect('hello world').toInclude('world')\n```\n\nAliases:\n  - `toContain`\n\n### toExclude\n\n> `expect(array).toExclude(value, [comparator], [message])`<br>\n> `expect(object).toExclude(value, [comparator], [message])`<br>\n> `expect(string).toExclude(value, [message])`\n\nAsserts that a given `value` is not included (or \"contained\") within another. The `actual` value may be an array, object, or a string. The `comparator` function, if given, should compare two objects and `return false` if they are not equal. The default is to use [`isEqual`](https://github.com/ljharb/is-equal).\n\n```js\nexpect([ 1, 2, 3 ]).toExclude(4)\nexpect({ a: 1, b: 2 }).toExclude({ c: 2 })\nexpect({ a: 1, b: 2 }).toExclude({ b: 3 })\nexpect({ a: 1, b: 2, c: { d: 3 } }).toExclude({ c: { d: 4 } })\nexpect('hello world').toExclude('goodbye')\n```\n\nAliases:\n  - `toNotContain`\n  - `toNotInclude`\n\n### toIncludeKey(s)\n\n> `expect(object).toIncludeKeys(keys, [comparator], [message])`<br>\n> `expect(object).toIncludeKey(key, [comparator], [message])`\n\nAsserts that the given `object` (may be an array, or a function, or anything with keys) contains *all* of the provided keys. The optional parameter `comparator` is a function which if given an object and a string key, it should return a boolean detailing whether or not the key exists in the object. By default, a shallow check with `Object.prototype.hasOwnProperty` is performed.\n\n```js\nexpect({ a: 1 }).toIncludeKey('a')\nexpect({ a: 1, b: 2 }).toIncludeKeys([ 'a', 'b' ])\n```\n\nAliases:\n  - `toContainKey(s)`\n\n### toExcludeKey(s)\n\n> `expect(object).toExcludeKeys(keys, [comparator], [message])`<br>\n> `expect(object).toExcludeKey(key, [comparator], [message])`\n\nAsserts that the given `object` (may be an array, or a function, or anything with keys) does not contain *any* of the provided keys. The optional parameter `comparator` is a function which if given an object and a string key, it should return a boolean detailing whether or not the key exists in the object. By default, a shallow check with `Object.prototype.hasOwnProperty` is performed.\n\n```js\nexpect({ a: 1 }).toExcludeKey('b')\nexpect({ a: 1, b: 2 }).toExcludeKeys([ 'c', 'd' ])\n```\n\nAliases:\n  - `toNotContainKey(s)`\n  - `toNotIncludeKey(s)`\n\n### (spy) toHaveBeenCalled\n\n> `expect(spy).toHaveBeenCalled([message])`\n\nAsserts the given `spy` function has been called at least once.\n\n```js\nexpect(spy).toHaveBeenCalled()\n```\n\n### (spy) toNotHaveBeenCalled\n\n> `expect(spy).toNotHaveBeenCalled([message])`\n\nAsserts the given `spy` function has *not* been called.\n\n```js\nexpect(spy).toNotHaveBeenCalled()\n```\n\n### (spy) toHaveBeenCalledWith\n\n> `expect(spy).toHaveBeenCalledWith(...args)`\n\nAsserts the given `spy` function has been called with the expected arguments.\n\n```js\nexpect(spy).toHaveBeenCalledWith('foo', 'bar')\n```\n\n## Chaining Assertions\n\nEvery assertion returns an `Expectation` object, so you can chain assertions together.\n\n```js\nexpect(3.14)\n  .toExist()\n  .toBeLessThan(4)\n  .toBeGreaterThan(3)\n```\n\n## Spies\n\nexpect also includes the ability to create spy functions that can track the calls that are made to other functions and make various assertions based on the arguments and context that were used.\n\n```js\nvar video = {\n  play: function () {},\n  pause: function () {},\n  rewind: function () {}\n}\n\nvar spy = expect.spyOn(video, 'play')\n\nvideo.play('some', 'args')\n\nexpect(spy.calls.length).toEqual(1)\nexpect(spy.calls[0].context).toBe(video)\nexpect(spy.calls[0].arguments).toEqual([ 'some', 'args' ])\nexpect(spy).toHaveBeenCalled()\nexpect(spy).toHaveBeenCalledWith('some', 'args')\n\nspy.restore()\nexpect.restoreSpies()\n```\n\n### createSpy\n\n> `expect.createSpy()`\n\nCreates a spy function.\n\n```js\nvar spy = expect.createSpy()\n```\n\n### spyOn\n\n> `expect.spyOn(target, method)`\n\nReplaces the `method` in `target` with a spy.\n\n```js\nvar video = {\n  play: function () {}\n}\n\nvar spy = expect.spyOn(video, 'play')\nvideo.play()\n\nspy.restore()\n```\n\n### restoreSpies\n\n> `expect.restoreSpies()`\n\nRestores all spies created with `expect.spyOn()`. This is the same as calling `spy.restore()` on all spies created.\n\n```js\n// mocha.js example\nbeforeEach(function () {\n  expect.spyOn(profile, 'load')\n})\n\nafterEach(function () {\n  expect.restoreSpies()\n})\n\nit('works', function () {\n  profile.load()\n  expect(profile.load).toHaveBeenCalled()\n})\n```\n\n## Spy methods\n\n### andCall\n\n> `spy.andCall(fn)`\n\nMakes the spy invoke a function `fn` when called.\n\n```js\nvar dice = createSpy().andCall(function () {\n  return (Math.random() * 6) | 0\n})\n```\n\n### andCallThrough\n\n> `spy.andCallThrough()`\n\nMakes the spy call the original function it's spying on.\n\n```js\nspyOn(profile, 'load').andCallThrough()\n\nvar getEmail = createSpy(function () {\n  return \"hi@gmail.com\"\n}).andCallThrough()\n```\n\n### andReturn\n\n> `spy.andReturn(object)`\n\nMakes the spy return a value.\n\n```js\nvar dice = expect.createSpy().andReturn(3)\n```\n\n### andThrow\n\n> `spy.andThrow(error)`\n\nMakes the spy throw an `error` when called.\n\n```js\nvar failing = expect.createSpy()\n  .andThrow(new Error('Not working'))\n```\n\n### restore\n\n> `spy.restore()`\n\nRestores a spy originally created with `expect.spyOn()`.\n\n### reset\n\n> `spy.reset()`\n\nClears out all saved calls to the spy.\n\n## Extending expect\n\nYou can add your own assertions using `expect.extend` and `expect.assert`:\n\n```js\nexpect.extend({\n  toBeAColor() {\n    expect.assert(\n      this.actual.match(/^#[a-fA-F0-9]{6}$/),\n      'expected %s to be an HTML color',\n      this.actual\n    )\n    return this\n  }\n})\n\nexpect('#ff00ff').toBeAColor()\n```\n\n## Extensions\n\n- [expect-element](https://github.com/mjackson/expect-element) Adds assertions that are useful for DOM elements\n- [expect-jsx](https://github.com/algolia/expect-jsx) Adds things like `expect(ReactComponent).toEqualJSX(<TestComponent prop=\"yes\" />)`\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/mjackson/expect.git"
  },
  "scripts": {
    "build": "node ./scripts/build.js",
    "build-cjs": "rimraf lib && babel ./modules -d lib --ignore '__tests__'",
    "build-min": "NODE_ENV=production webpack -p modules/index.js umd/expect.min.js",
    "build-umd": "NODE_ENV=production webpack modules/index.js umd/expect.js",
    "lint": "eslint modules",
    "prepublish": "npm run build",
    "release": "node ./scripts/release.js",
    "test": "npm run lint && karma start"
  },
  "version": "1.19.0"
}
